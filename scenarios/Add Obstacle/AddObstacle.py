import random

from beamngpy import BeamNGpy, Scenario, Road, Vehicle, setup_logging, ProceduralCube
import numpy as np
import os
import matplotlib.pyplot as plt
from datetime import datetime
from time import sleep
from matplotlib.pyplot import imshow
from PIL import Image
from shapely.geometry import Polygon




# defining the global variable


# defining the beamng requirments
beamng = BeamNGpy('localhost', 64256)
beamng_modify = BeamNGpy('localhost', 64256)
beamng_random = BeamNGpy('localhost', 64256)
main_scenario = Scenario('GridMap', 'the main scenario ')
modify_scenario = Scenario('GridMap','the scenario with the modification if y coordinate in obstacle in comparison with main scenario')
random_scenario = Scenario('GridMap','the scenario with random road generated')
vehicle = Vehicle('ego_vehicle', model='etk800')


# defining the changable variable
n_iterate = 10
amount_of_iterate = 40
number_of_object = 8
orig = (-800, 400, 0, 7)

# making the path for generating the
path = "testing-" + str(datetime.now().date()) + "-" + str(datetime.now().time().hour) + "-" + str(datetime.now().time().minute) + "-" + str(datetime.now().time().second)
threshold = (orig[0] + amount_of_iterate, orig[1] - n_iterate * amount_of_iterate, 0)

# the list
script = list()
object_list = list()
script_x = list()
script_y = list()


def making_road(n, ei):
    # adding the Road and the lines
    road_main = Road('track_editor_C_center',rid='main_road',drivability=1,texture_length =5, interpolate = True)

    i = 0
    while i < n:
        nodes_main_road = [
            (orig[0] + ((i%2) * ei) , orig[1] - i*ei , 0, 10),
            # (orig[0] + ((i+1)%2) * ei, orig[1] - i * ei - ei, 0, 5),
        ]
        #adding the roads
        road_main.nodes.extend(nodes_main_road)
        i = i + 1

    # adding the road to the scenario
    main_scenario.add_road(road_main)
    modify_scenario.add_road(road_main)



def making_random_road(n, ei):

    # adding the Road and the lines
    road_random_main = Road('track_editor_C_center', rid='random_road', drivability=1, texture_length=5, interpolate=True)
    nodes_main_road =[orig[0],orig[1],orig[2],orig[3]]
    road_random_main.nodes.extend(nodes_main_road)
    i = 1
    while i < n:
        nodes_main_road = [
            (random.uniform(orig[0],orig[0]+ei) , orig[1] - i*ei , 0, 10),
        ]
        #adding the roads
        road_random_main.nodes.extend(nodes_main_road)
        i = i + 1

    # adding the road to the scenario
    random_scenario.add_road(road_random_main)



# defining the vehicle
def making_vehicle(n,ei):
    # adding the Vehicle

    main_scenario.add_vehicle(vehicle, pos=(orig[0],orig[1]+5,orig[2],orig[3]), rot=None, rot_quat=(0, 0, 0, 1))
    modify_scenario.add_vehicle(vehicle, pos=(orig[0],orig[1]+5,orig[2],orig[3]), rot=None, rot_quat=(0, 0, 0, 1))
    random_scenario.add_vehicle(vehicle, pos=(orig[0],orig[1]+5,orig[2],orig[3]), rot=None, rot_quat=(0, 0, 0, 1))

    # setting points for autopilot
    i = 0
    j = 0
    bool =True
    while i < n_iterate * amount_of_iterate:
        if i % amount_of_iterate == 0:
            if bool:
                j = 1
                bool =False
            else:
                j = 0
                bool = True


        node_point_driving = {

            'x': orig[0] + (j % 2) * (i % amount_of_iterate) + (j+1 % 2) * (amount_of_iterate - (i % amount_of_iterate )),
            'y': -(i * 1) + orig[1],
            'z': orig[2],
            't': (2 * i + (np.abs(np.sin(np.radians(i)))) * 64) / 8,
        }
        script.append(node_point_driving)
        i = i + 1
    script_x = [s['x'] for s in script]
    script_y = [s['y'] for s in script]

# adding the obstacle to the
def make_obstacle(o, t):
    position = (random.uniform(o[0], t[0]), random.uniform(o[1], t[1]), o[2])
    object_list.append(position)
    cube1 =ProceduralCube(name='cube1', pos=(position), rot=None, rot_quat=(1, 0, 0, 0), size=(1, 1, 10))
    main_scenario.add_procedural_mesh(cube1)
    random_scenario.add_procedural_mesh(cube1)

# modify the position of the obstacle only in y coordinate
def change_position_of_obstacle(o, t):
    i = 0
    while i< number_of_object:
        cube2 =ProceduralCube(name='cube1', pos=(object_list[i][0],object_list[i][1]+10, object_list[i][2]), rot=None, rot_quat=(1, 0, 0, 0), size=(1, 1, 10))
        modify_scenario.add_procedural_mesh(cube2)
        i = i + 1

# function for the main approches
def main_scenario_func():
    # call function for defining the vehicle
    making_vehicle(n_iterate, amount_of_iterate)

    # call function for defining the road
    making_road(n_iterate, amount_of_iterate)

    # call function for defining the object
    i = 0
    while i < number_of_object:
        make_obstacle(orig, threshold)
        i = i + 1

    # make the scenario then load and then start it
    main_scenario.make(beamng)
    bng = beamng.open(launch=True)
    try:

        bng.load_scenario(main_scenario)
        bng.start_scenario()
        making_plot_road(bng, "main")
        vehicle.ai_set_script(script)
        sleep(20)
    finally:
        bng.close()

# function for the modifying the main function and run it again
def modify_scenario_func():
    # call function for defining the object
    change_position_of_obstacle(orig, threshold)

    # make the scenario then load and then start it
    modify_scenario.make(beamng_modify)
    bng = beamng_modify.open(launch=True)
    try:
        bng.load_scenario(modify_scenario)
        bng.start_scenario()
        making_plot_road(bng,"modify")
        vehicle.ai_set_script(script)
        sleep(20)
    finally:
        bng.close()

# this function is for making the random road in the envoironment
def random_scenario_func():

    # make the scenario then load and then start it
    random_scenario.make(beamng_random)
    bng = beamng_random.open(launch=True)
    try:

        bng.load_scenario(random_scenario)
        bng.start_scenario()
        making_plot_road(bng,"random")
        vehicle.ai_set_script(script)
        sleep(20)
    finally:
        bng.close()


# making the plot from road nad the script of the vehicle
def making_plot_road(bng, type):
    if type == "random":
        road_geometry = bng.get_road_edges('random_road')
        left_edge_x = np.array([e['left'][0] for e in road_geometry])
        left_edge_y = np.array([e['left'][1] for e in road_geometry])
        right_edge_x = np.array([e['right'][0] for e in road_geometry])
        right_edge_y = np.array([e['right'][1] for e in road_geometry])
        plt.figure(figsize=(10, 10))
        plot_road(plt.gca(), left_edge_x, left_edge_y, right_edge_x, right_edge_y)
        plot_script(plt.gca())
        print("random func")
        plt.savefig("outcome/" + path + "/random.png")

    else:
        road_geometry = bng.get_road_edges('main_road')
        left_edge_x = np.array([e['left'][0] for e in road_geometry])
        left_edge_y = np.array([e['left'][1] for e in road_geometry])
        right_edge_x = np.array([e['right'][0] for e in road_geometry])
        right_edge_y = np.array([e['right'][1] for e in road_geometry])
        plt.figure(figsize=(10, 10))
        plot_road(plt.gca(), left_edge_x, left_edge_y, right_edge_x, right_edge_y)
        plot_script(plt.gca())
        if type == "main":
            print("main func")
            plt.savefig("outcome/" + path + "/main.png")

        else:
            print("modify func")
            plt.savefig("outcome/" + path + "/modify.png")

def plot_road(ax,left_edge_x,left_edge_y,right_edge_x,right_edge_y):
    x_min = min(left_edge_x.min(), right_edge_x.min()) - 10  # We add/subtract 10 from the min/max coordinates to pad
    x_max = max(left_edge_x.max(), right_edge_x.max()) + 10  # the area of the plot a bit
    y_min = min(left_edge_y.min(), right_edge_y.min()) - 10
    y_max = max(left_edge_y.max(), right_edge_y.max()) + 10
    ax.set_aspect('equal', 'datalim')
    ax.set_xlim(left=x_max, right=x_min)  # pyplot & bng coordinate systems have different origins
    ax.set_ylim(bottom=y_max, top=y_min)  # so we flip them here
    ax.plot(left_edge_x, left_edge_y, 'b-')
    ax.plot(right_edge_x, right_edge_y, 'b-')


def plot_script(ax):
    ax.plot(script_x, script_y, 'y-')

def executor():
    main_scenario_func()
    modify_scenario_func()
    random_scenario_func()




if __name__ == '__main__':
    os.mkdir("outcome/"+path)
    executor()
