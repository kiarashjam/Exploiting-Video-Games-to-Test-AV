
import numpy as np


from beamngpy import BeamNGpy, Scenario, Road, Vehicle, setup_logging
from beamngpy import ProceduralCylinder, ProceduralCone, ProceduralCube, ProceduralBump, ProceduralRing, StaticObject

SIZE = 1024

# adding object / some kind of sign in the street  


def make_object_left(i,node):
    object = StaticObject(name='tree', shape='sign_truss1.dae',
                        pos=(node['x']-6, node['y'], node['z'] +(i*-0.012)), rot=None, rot_quat=(1, 0, 0, 0), scale=("1 1 1"))
    return object

def make_object_right(i,node):
    object = StaticObject(name='tree', shape='sign_truss1.dae',
                        pos=(node['x']+6, node['y'], node['z'] +(i*-0.012)), rot=None, rot_quat=(1, 0, 0, 0), scale=("1 1 1"))
    return object
# adding the cube into the left and right of the project 

def make_cube_left(i, node):


    cube1 = ProceduralCube(name='cube1', pos=(node['x']-4, node['y'], node['z'] +(i*-0.012)),
                          rot=None, rot_quat=(1, 0, 0, 0), size=(1, 1, 10))
    return cube1


def make_cube_right(i, node):
    cube2 = ProceduralCube(name='cube2', pos=(node['x'] + 4, node['y'], node['z'] + (i * -0.012)),
                           rot=None, rot_quat=(1, 0, 0, 0), size=(1, 1, 10))
    return cube2


def main():
    setup_logging()
    orig = (-769.1, 400.8, 142.8)

    beamng = BeamNGpy('localhost', 64256)
    scenario = Scenario('smallgrid', ' testing the scenario ')

    vehicle = Vehicle('ego_vehicle', model='etk800' , licence='AI')
    scenario.add_vehicle(vehicle, pos=orig, rot=None, rot_quat=(0, 0, 1, 0))



    # scenario.add_vehicle(vehicle, pos=orig, rot=None, rot_quat=(0, 0, 1, 0))
    scenario.make(beamng)

    script = list()

    points = list()
    point_colors = list()

    # defining one loop for making the driving in auto mode and also curvely 
    for i in range(3600):
        node = {

            #  Calculate the position as a sinus curve that makes the vehicle
            #  drive from left to right.
            
            'x': 4 * np.sin(np.radians(i)) + orig[0],
            'y': i * 0.1 + orig[1],
            'z': orig[2],
            #  Calculate timestamps for each node such that the speed between
            #  points has a sinusoidal variance to it.
            't': (2 * i + (np.abs(np.sin(np.radians(i)))) * 64) / 64,
        }

        script.append(node)
        points.append([node['x'], node['y'], node['z']])
        point_colors.append([0, np.sin(np.radians(i)), 0, 0.1])
        # adding the object in the left and right part of the road 
        if i % 50 == 0:
            scenario.add_object(make_object_right(i,node))
            scenario.add_object(make_object_left(i,node))
            scenario.add_procedural_mesh(make_cube_left(i,node))
            scenario.add_procedural_mesh(make_cube_right(i,node))


    # starting the scenario 
    bng = beamng.open(launch=True)
    try:
        bng.load_scenario(scenario)

        bng.start_scenario()
        bng.add_debug_line(points, point_colors,spheres=spheres, sphere_colors=sphere_colors, cling=True, offset=0.1)
        vehicle.ai_set_script(script)

        while True:
            bng.step(60)
    finally:
        bng.close()


if __name__ == '__main__':
    main()
